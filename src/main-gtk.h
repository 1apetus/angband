/*
 * File: main-gtk.h
 * Purpose: Header file for the GTK port for Angband
 *
 * Copyright (c) 2000-2007 Robert Ruehlmann, Shanoah Alkire
 *
 * This work is free software; you can redistribute it and/or modify it
 * under the terms of either:
 *
 * a) the GNU General Public License as published by the Free Software
 *    Foundation, version 2, or
 *
 * b) the "Angband licence":
 *    This software may be copied and distributed for educational, research,
 *    and not for profit purposes provided that this copyright and statement
 *    are included in all such copies.  Other copyrights may also apply.
 */
#ifndef INCLUDED_MAIN_GTK_H
#define INCLUDED_MAIN_GTK_H

#include "main.h"
#include "cairo-utils.h"
#include "game-cmd.h" 
#include "game-event.h" 

#include <gtk/gtk.h>
#include <gdk/gdkkeysyms.h>
#include <glade/glade.h>

#define USE_PANGO
#define MAX_TERM_DATA 8
#define USE_GRAPHICS
#define MAIN_WINDOW(td) (td == &data[0])
/*#define USE_GUI_SELECTION*/

typedef struct term_data term_data;
typedef struct point point;
typedef struct measurements measurements;
typedef struct xtra_win_data xtra_win_data;
struct point
{
	int x,y;
};

struct measurements
{
	int w,h;
};

/*
 * Extra data to associate with each "window"
 *
 * Each "window" is represented by a "term_data" structure, which
 * contains a "term" structure, which contains a pointer (t->data)
 * back to the term_data structure.
 */

struct term_data
{
	term t;
	cptr name;
	
	bool visible;
	int rows;
	int cols;
	point location;
	measurements size; /* of the window */
	
	measurements tile, font_size;
	
	cairo_surface_t *surface;
	cairo_t *cr;
	PangoFontDescription *font;
	cairo_scaled_font_t *c_font;
	cairo_matrix_t matrix;
	cptr font_name;
	double font_pt;

	GtkWidget *window;
	GtkWidget *drawing_area;
	GladeXML *xml;
};

struct xtra_win_data
{
	cptr name, win_name, text_view_name, item_name;
	bool visible;
	
	GtkWidget *win, *text_view, *menu;
	measurements size;
	point location;
};

char xtra_names[5][20] =
{
	"Messages",
	"Inventory",
	"Equipment",
	"Monster List",
	"Debug"
};
char xtra_win_names[5][20] =
{
	"message_window",
	"inv_window",
	"equip_window",
	"monst_list_window",
	"debug_window"
};
char xtra_text_names[5][20] =
{
	"message_text",
	"inv_text",
	"equip_text",
	"monst_list_text",
	"debug_text"
};
char xtra_menu_names[5][20] =
{
	"messages_item",
	"inv_item",
	"equip_item",
	"monst_list_item",
	"debug_item"
};
/*
 * An array of "term_data" structures, one for each "sub-window"
 */
static term_data data[MAX_TERM_DATA];

/*
 * A similar array for my extra, non-term windows.
 */
static xtra_win_data xdata[5];

/* 
 * There are a few functions installed to be triggered by several 
 * of the basic player events.  For convenience, these have been grouped 
 * in this list that I swiped from xtra3.c. These really should be in one of the 
 * headers, shouldn't they?
 */
game_event_type my_player_events[] =
{
	EVENT_RACE_CLASS,
	EVENT_PLAYERTITLE,
	EVENT_EXPERIENCE,
	EVENT_PLAYERLEVEL,
	EVENT_GOLD,
	EVENT_EQUIPMENT,  /* For equippy chars */
	EVENT_STATS,
	EVENT_HP,
	EVENT_MANA,
	EVENT_AC,

	EVENT_MONSTERHEALTH,

	EVENT_PLAYERSPEED,
	EVENT_DUNGEONLEVEL,
};

game_event_type my_statusline_events[] =
{
	EVENT_STUDYSTATUS,
	EVENT_STATUS,
	EVENT_DETECTIONSTATUS,
	EVENT_STATE,
};

/* 
 *An array of colors in string format.  
 * Easily generated by sprintf(color, "#%02x%02x%02x", 
 * angband_color_table[i][1], angband_color_table[i][2], angband_color_table[i][3]);
 * if needed, but tables are a bit faster.
 */
char color_string_table[MAX_COLORS][8] =
{
	"#000000",	/* TERM_DARK */
	"#FFFFFF",	/* TERM_WHITE */
	"#808080",	/* TERM_SLATE */
	"#FF8000",	/* TERM_ORANGE */
	"#C00000",	/* TERM_RED */
	"#008040",	/* TERM_GREEN */
	"#0040FF",	/* TERM_BLUE */
	"#804000",	/* TERM_UMBER */
	"#606060",	/* TERM_L_DARK */
	"#C0C0C0",	/* TERM_L_WHITE */
	"#FF00FF",	/* TERM_VIOLET */
	"#FFFF00",	/* TERM_YELLOW */
	"#FF4040",	/* TERM_L_RED */
	"#00FF00",	/* TERM_L_GREEN */
	"#00FFFF",	/* TERM_L_BLUE */
	"#C08040"	/* TERM_L_UMBER */
};

/* 
 * The names  
 */
static void save_prefs(void);
bool ignore_prefs = FALSE;
static bool game_in_progress = FALSE;
static int num_term = 8;

/* Command line help */
const char help_gtk[] = "GTK for X11, subopts -n<windows>, -i to ignore prefs, and standard GTK options";

/*  Path to the Gtk settings file */
char settings[1024];

/* Logging function */
void gtk_log_fmt(byte c, cptr fmt, ...);

/* Cairo functions */


/* Erase the whole term. */
static errr Term_clear_gtk(void);

/* Erase n chars at x/y */
static errr Term_wipe_gtk(int x, int y, int n);

/* Draw string s of n chars at x/y, in color a, using pango/cairo */
static errr Term_text_gtk(int x, int y, int n, byte a, cptr s);

/* Draw a tile in cairo */
/*void draw_tile( int x, int y, int tx, int ty, cairo_t *cr, cairo_matrix_t m);*/

/* Draw tiles in cairo, using draw tile for the individual ones */
static errr Term_pict_gtk(int x, int y, int n, const byte *ap, const char *cp, const byte *tap, const char *tcp);

/* Draw a cursor in cairo */
static errr Term_curs_gtk(int x, int y);

/* Flush Gtk */
static errr Term_flush_gtk(void);

/* Do extra stuff */
static errr Term_xtra_gtk(int n, int v);

/* Check it */
static errr CheckEvent(bool wait);

/* Redraw stuff */
static void term_data_redraw(term_data *td);

/* Show a term window */
static void Term_show(term_data *td);

/* Hide one */
static void Term_hide(term_data *td);

/* Window and menu code */

/* Get the current size and positions of a term window */
static void get_size_pos(term_data *td);

/* Iterate get_size_pos */
static void get_term_sizes();

/* Set the term window sizes and hints up */
static void set_window_size(term_data *td);

/* Save the game */
static bool save_game_gtk(void);

/* hook for quitting */
static void hook_quit(cptr str);

/* Gtk Events */

/* Signal to quit sent */
gboolean quit_event_handler(GtkWidget *widget, GdkEventButton *event, gpointer user_data);

/* Signal to destroy a window */
gboolean destroy_event_handler(GtkWidget *widget, GdkEventButton *event, gpointer user_data);
gboolean delete_event_handler(GtkWidget *widget, GdkEvent *event, gpointer user_data);

/* Toggle if a window is hidden or not */
gboolean on_window_toggle(GtkWidget *widget, GdkEvent *event, gpointer user_data);

/* Signal to hide a window */
gboolean hide_event_handler(GtkWidget *widget, GdkEventButton *event, gpointer user_data);

/* signal to show a window */
gboolean new_event_handler(GtkWidget *widget, GdkEventButton *event, gpointer user_data);

/* Signal to save the game */
gboolean save_event_handler(GtkWidget *widget, GdkEvent *event, gpointer user_data);

/* Signal that keys were pressed */
gboolean keypress_event_handler(GtkWidget *widget, GdkEventKey *event, gpointer user_data);

/* signal that the mouse was clicked */
gboolean on_mouse_click(GtkWidget *widget, GdkEventButton *event, gpointer user_data);

/* Signal to redraw the window */
gboolean expose_event_handler(GtkWidget *widget, GdkEventExpose *event, gpointer user_data);

/* Signal to toggle a window option */
gboolean term_attr_change(GtkWidget *widget, GdkEvent *event, gpointer user_data);

/* Signal to show what will eventually be an options window */
gboolean show_options_window(GtkWidget *widget, GdkEvent *event, gpointer user_data);

/* Signal to hide the "options" window */
gboolean hide_options_window(GtkWidget *widget, GdkEvent *event, gpointer user_data);

/* Activate the four graphics types */
gboolean on_no_graphics_activate(GtkWidget *widget, GdkEventExpose *event, gpointer user_data);
gboolean on_old_graphics_activate(GtkWidget *widget, GdkEventExpose *event, gpointer user_data);
gboolean on_adam_bolt_graphics_activate(GtkWidget *widget, GdkEventExpose *event, gpointer user_data);
gboolean on_david_gervais_graphics_activate(GtkWidget *widget, GdkEventExpose *event, gpointer user_data);

/* The open dialog */
void open_event_handler(GtkButton *was_clicked, gpointer user_data);

/* helper functions */

/* Given a name, load a font, and determine it's size */
static void load_font_by_name(term_data *td, cptr fontname);

/* Set the font from a dialog */
void set_font(GtkWidget *widget, GtkWidget *font_dialog);
void change_font_event_handler(GtkWidget *widget, gpointer user_data);

/* Filter what is shown in the open/save dialog */
static gboolean file_open_filter(const GtkFileFilterInfo *filter_info, gpointer data);

/* Show the open/save dialog */
static bool save_dialog_box(bool save);

/* Pref helper functions */
static int check_env_i(char* name, int i, int dfault);
static int get_value(cptr buf);

/* Save the prefs */
static void save_prefs(void);

/* Load the prefs */
static void load_prefs(term_data *td, int i);

/* Helper function - convert a pixel to a char */
static void pixel_to_square(int * const x, int * const y, const int ox, const int oy);
 
/* Update the term menu re whether windows are visible */
static void update_term_menu(void);

/* Update the windows themselves, re whether they are visible */
static void update_windows(void);

/* Update the graphics menu */
static void setup_graphics_menu();

/* Actually set up what graphics are used */
static void init_graf(int g);

/* Init my windows */
static void init_gtk_windows(void);

/* Init the term-data */
static errr term_data_init(term_data *td, int i);

/* Init gtk */
errr init_gtk(int argc, char **argv);

#endif /* INCLUDED_MAIN_GTK_H */

