#ifndef INCLUDED_UI_MENU_H
#define INCLUDED_UI_MENU_H

/*** Constants ***/

/* Colors for interactive menus */
enum
{
	CURS_UNKNOWN = 0,		/* Use gray / dark blue for cursor */
	CURS_KNOWN = 1			/* Use white / light blue for cursor */
};

/* Cursor colours for different states */
extern const byte curs_attrs[2][2];

/* Standard menu orderings */
extern const char lower_case[];			/* abc..z */
extern const char upper_case[];			/* ABC..Z */


typedef struct menu_item menu_item;
typedef struct menu_type menu_type;
typedef struct menu_skin menu_skin;
typedef struct menu_iter menu_iter;


/* ================== MENUS ================= */

/* 
 * Displays a single row in a menu
 * Driver function for populating a single menu row.
 * Member function for "menu_iter" VTAB
 */
typedef void (*display_row_f) (menu_type *menu, int pos,
			       bool cursor, int row, int col, int width);

/* 
 * Driver function for displaying a page of rows.
 * Member function of "menu_skin" VTAB
 */
typedef void (*display_list_f)(menu_type *menu, int cursor, int *top, region *);


/* Primitive menu item with bound action */
typedef struct menu_action
{
	int id;			/* Object id used to define macros &c */
	const char *name;	/* Name of the action */
	void (*action)(const char *name, int row); /* Action to perform */
} menu_action;


/* Decorated menu item with bound action */
struct menu_item
{
	menu_action act; /* Base type */
	char sel;        /* Character used for selection, if special-purpose */
	                 /* bindings are desired. */
	int flags;	 /* State of the menu item.  See menu flags below */
};


/* TODO: menu registry */
/*
  Together, these classes define the constant properties of
  the various menu classes.

  A menu consists of:
   - menu_iter, which describes how to handle the type of "list" that's 
     being displayed as a menu
   - a menu_skin, which describes the layout of the menu on the screen.
   - various bits and bobs of other data (e.g. the actual list of entries)
 */


/* Flags for menu appearance & behavior */
/* ==================================== */

/* Tags are associated with the view, not the element */
#define MN_REL_TAGS 0x0100 

/* No tags -- movement key and mouse browsing only */
#define MN_NO_TAGS  0x0200 

/* Tags to be generated by the display function */
#define MN_PVT_TAGS  0x0400 

/* Tag selections can be made regardless of the case of the key pressed. 
 * i.e. 'a' activates the line tagged 'A'. */
#define MN_CASELESS_TAGS 0x0800 

/* double tap (or keypress) for selection; single tap is cursor movement */
#define MN_DBL_TAP 0x1000 



/* Row flags in action_menu structure. */
#define MN_DISABLED   0x0100000 /* Neither action nor selection is permitted */
#define MN_GRAYED     0x0200000 /* Row is displayed with CURS_UNKNOWN colors */
#define MN_GREYED     0x0200000 /* Row is displayed with CURS_UNKNOWN colors */
#define MN_SELECTED   0x0400000 /* Row is currently selected */
#define MN_SELECTABLE 0x0800000 /* Row is permitted to be selected */
#define MN_HIDDEN     0x1000000 /* Row is hidden, but may be selected via */
                                /* key-binding.  */


/** Identifier for the type of menu layout to use */
typedef enum
{
	MN_SKIN_SCROLL = 1,   /**< Ordinary scrollable single-column list */
	MN_SKIN_COLUMNS = 2   /**< Multicolumn view */
} skin_id;


/* Class functions for menu layout */
struct menu_skin
{
	/* Determines the cursor index given a (mouse) location */
	int (*get_cursor)(int row, int col, int n, int top, region *loc);
	/* Displays the current list of visible menu items */
	display_list_f display_list;
	/* Specifies the relative menu item given the state of the menu */
	char (*get_tag)(menu_type *menu, int pos);
};


/* Identifiers for canned row iterator implementations */
typedef enum
{
	/* A simple list of actions with an associated name and id.
	   An array of menu_action */
	MN_ITER_ACTIONS = 1,

	/* Slightly more sophisticated, a list of menu items that also
	   allows per-item flags and a "selection" character to be specified.
	   An array of menu_item */
	MN_ITER_ITEMS   = 2,

	/* A list of strings to be selected from - no associated actions.
	   An array of const char * */
	MN_ITER_STRINGS = 3
} menu_iter_id;


/* Class functions for menu row-level accessor functions */
struct menu_iter
{
	/* Optional selection tag function */
	char (*get_tag)(menu_type *menu, int oid);

	/* Optional validity checker.  All rows are assumed valid if not present. */
 	/* To support "hidden" items, it uses 3-level logic: 0 = no  1 = yes 2 = hide */
	int (*valid_row)(menu_type *menu, int oid);

	/* Displays a menu row at specified location */
	display_row_f display_row;

	/* Handler function called for 'positive' events (selections or cmd_keys) */
	bool (*row_handler)(menu_type *menu, const ui_event_data *event, int oid);

	/* Redraw hook */
	void (*resize)(menu_type *m);
};


/* A menu defines either an action
 * or db row event
 */
struct menu_type
{
	/* menu inherits from panel */
	region boundary;

	/* set of commands that may be performed on a menu item */
	const char *cmd_keys;

	/* Public variables */
	const char *title;
	const char *prompt;

	/* Keyboard shortcuts for menu selection */
	/* IMPORTANT: this cannot intersect with cmd_keys */
	const char *selections; 

	int flags;              /* Flags specifying the behavior of this menu. */
	int filter_count;       /* number of rows in current view */
	const int *filter_list;       /* optional filter (view) of menu objects */

	int count;              /* number of rows in underlying data set */
	void *menu_data;  /* the data used to access rows. */

  	/* auxiliary browser help function */
	void (*browse_hook)(int oid, void *db, const region *loc);

	/* These are "protected" - not visible for canned menu classes, */
	/* The per-row functions  */
	const menu_iter *row_funcs;


	/* State variables for the menu */
	int cursor;             /* Currently selected row */
	int top;                /* Position in list for partial display */
	region active;          /* Subregion actually active for selection */

	/* helper functions for layout information. */
	const menu_skin *skin;  /* Defines menu appearance */
};



/*** Menu API ***/

/**
 * Initialise a menu, using the skin and iter functions specified.
 */
void menu_init(menu_type *menu, skin_id skin, const menu_iter *iter);


/**
 * Given a predefined menu kind, return its iter functions.
 */
const menu_iter *menu_find_iter(menu_iter_id iter_id);


/**
 * Set menu private data and the number of menu items.
 *
 * Menu private data is then available from inside menu callbacks using
 * menu_priv().
 */
void menu_setpriv(menu_type *menu, int count, void *data);


/**
 * Return menu private data, set with menu_setpriv().
 */
void *menu_priv(menu_type *menu);


/*
 * Set a filter on what items a menu can display.
 *
 * Use this if your menu private data has 100 items, but you want to choose
 * which ones of those to display at any given time, e.g. in an inventory menu.
 * object_list[] should be an array of indexes to display, and n should be its
 * length.
 */
void menu_set_filter(menu_type *menu, const int object_list[], int n);


/**
 * Remove any filters set on a menu by menu_set_filer().
 */
void menu_release_filter(menu_type *menu);


/**
 * Ready a menu for display in the region specified.
 *
 * XXX not ready for dynamic resizing just yet
 */
bool menu_layout(menu_type *menu, const region *loc);


/**
 * Display a menu.
 */
void menu_refresh(menu_type *menu);


/**
 * Run a menu.
 *
 * 'notify' is a bitwise OR of ui_event_type events that you want to
 * menu_select to return to you if they're not handled inside the menu loop.
 * e.g. if you want to handle key events without specifying a menu_iter->handle
 * function, you can set notify to EVT_KBRD, and any non-navigation keyboard
 * events will stop the menu loop and return them to you.
 *
 * Some events are returned by default, and else are EVT_ESCAPE and EVT_SELECT.
 * 
 * Event types that can be returned:
 *   EVT_ESCAPE: no selection; go back (by default)
 *   EVT_SELECT: menu->cursor is the selected menu item (by default)
 *   EVT_MOVE:   the cursor has moved
 *   EVT_KBRD:   unhandled keyboard events
 *   EVT_MOUSE:  unhandled mouse events  
 *   EVT_RESIZE: resize events
 * 
 * XXX remove 'notify'
 */
ui_event_data menu_select(menu_type *menu, int notify);



/* Interal menu stuff that cmd-know needs because it's quite horrible */
bool menu_handle_mouse(menu_type *menu, const ui_event_data *in, ui_event_data *out);
bool menu_handle_keypress(menu_type *menu, const ui_event_data *in, ui_event_data *out);

#endif /* INCLUDED_UI_MENU_H */
